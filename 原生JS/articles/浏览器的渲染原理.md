# 浏览器的渲染原理

大多数设备的刷新频率是60Hz，也就是说浏览器对每一帧画面的渲染工作要做16ms内完成，超出这个时间，页面的渲染就会出现卡顿，
从而影响用户体验。因此，对于B/S架构的开发人员来说，熟悉浏览器内部的执行原理显得尤为重要。

## 进程和线程

### 区分进程和线程
- 进程
    + 进程是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）
    + 我们可以打开资源管理器查看到每个进程的内存资源和CPU占有率
    + ![](https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list.png)
- 线程
    + 线程是CPU调度的最小单位
    + 线程是建立在进程的基础上的，一个进程可以划分为多个线程

### 浏览器是多进程的
- ![](https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list2.png)
- 一般一个浏览器页签就是一个进程

### 浏览器都包含哪些进程？
知道了浏览器是多进程后，再来看看它到底包含哪些进程：
1. Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有：
    - 负责浏览器界面显示与用户交互。如前进、后退等
    - 负责各个进程的管理，创建和销毁其他进程
    - 将Render进程得到的内存中的`Bitmap`，绘制到用户界面上
    - 网络资源的管理，下载等
2. 网络进程，负责网络资源的加载，之前是Browser进程下的一个线程
2. 插件进程，每个浏览器插件对应一个插件进程，使用沙盒隔离
3. GPU进程：只有一个，用于3D绘制
4. 浏览器渲染进程（浏览器内核）（Render进程，内部是多线程的）：默认每个Tab页一个Render进程，互不影响，主要作用为：
    - 页面渲染，脚本执行，事件处理等

### IPC进程间通信
- 进程和进程之间是相互独立，互不干扰的。但如果需要在进程间传输数据等就需要进行通信，一般有如下四种通信方式
1. 管道(包括无名管道和命名管道)
2. 信号
3. 消息队列
4. 共享内存
- 具体每种通信方式是如何工作的，在这里就不再展开，感兴趣可以自行查找相关资料

## 浏览器内核（渲染进程）
重点来了，上面提到了那么多的进程，对于我们普通前端来说，最重要的是什么呢？答案是渲染进程
> 明确一下，下文提到的任务队列、事件队列，都是指的同一个东西
#####
渲染进程主要包括：
1. GUI渲染线程
    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树，布局和绘制等
    - 当界面需要重绘（Repain）,或由于某种操作引发回流(reflow)时，该线程会执行
    - 注意：`GUI渲染线程和JS引擎线程互斥`，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等待JS引擎空闲时立即被执行。
2. JS引擎线程
    - 也称JS内核，负责处理Javascript脚本程序，运行Javascript代码。（如：V8引擎）
    - JS引擎一直等着任务队列中的任务到来，然后加以处理，一个Tab页(render进程)中无论什么时候都只有一个JS线程在运行JS程序
    - 同样注意：`GUI渲染线程和JS引擎线程互斥`，所以如果JS执行时间过长，会造成页面渲染不连贯，出现卡顿
3. 事件触发线程
    - 归属于浏览器而不是JS引擎，用来控制事件循环，（可以理解JS引擎自己都忙不过来，需要浏览器另开线程协助）
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到任务队列的队尾，等待JS引擎的处理
    - 注意，由于JS引擎的单线程关系，所以这些任务队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时器触发线程
    - 传说中的 `setInterval` 和 `setTimeout` 所在的线程
    - 浏览器定时器计数器并不是由Javascipt引擎计数的，（因为Javascript引擎是单线程的，但是处于阻塞线程状态就会影响计时的准确性）
    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    - 注意：W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms
        + 意味着你在一个setTimeout中传入的第二个时间参数，写0，1，2，3，4，都是一样的，最快也需要4ms后才能执行
5. 异步Http请求线程
    - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
    - 检测到状态变更时，如果设置有回调函数，异步线程就产生`状态变更事件`，将这个回调再放入事件队列中。再由Javascript引擎执行。
6. Event Loop轮询处理线程（轮询任务队列）
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611938b2d39a5b2~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 渲染流程
用户请求的HTML(text/html)文本通过浏览器的网络层到达渲染进程后，渲染工作开始。
- 用户在地址栏输入网址，并敲下回车键
- Browser主进程检查浏览器DNS缓存中是否有该域名对应的ip地址
- 如果没有命中，就查找操作系统DNS缓存(host文件)中是否有该域名对应的ip地址
- 还是没有命中，则操作系统将域名发送至本地域名服务器，查询本地域名服务器的DNS缓存
- 再没有命中，就由本地域名服务器向上级域名服务器递归查询

一图胜千言：
![](https://s5.51cto.com/images/blog/202112/10135340_61b2eb648bf9478151.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)
- 得到目标ip地址后，Browser进程通知网络进程新开一个线程发送文档获取请求。
- 网络进程获取到文档后，通过RendererHost接口传递给Renderer进程
- renderer进程的renderer接口接受到消息，简单解释后，交给渲染线程，然后开始渲染

webkit引擎渲染详细流程如下：
![](https://pic2.zhimg.com/80/v2-8bc7e081982113a4f99b6b76cef73631_1440w.jpg)

渲染流程主要有五个步骤：
1. 解析HTML标签，构建DOM树
2. 解析css，构建CSSOM树
3. 把DOM和CSSOM组合成渲染树（render tree）
    > 为了构建渲染树，浏览器大致执行以下操作：
    - 从DOM树的根开始，遍历每个可见节点
        + 一些节点是不可见的节点（例如：脚本标签、元标签等）被忽略，因为它们不会反应在渲染的输出中
        + 一些节点通过css隐藏，也从渲染树中忽略（display: none）
    - 对于每个可见节点，找到适当的匹配CSSOM规则并应用它们
    - 发出带有内容及其样式计算的节点
    - 最终输出的一个渲染树，包含屏幕上所有可见节点的内容和样式信息。有了渲染树，接下来就可以进入“布局”阶段
    ![](https://upload-images.jianshu.io/upload_images/1480597-c0d854c01697ceda.png?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

4. 在渲染树的基础上进行布局
    > 目前为止，我们已经计算了哪些节点应该是可见的以及它们的计算样式，但是我们还没有计算它们在设备视口中的确切位置和大小——这就是“布局”阶段，也称“回流”
    - 这一阶段的输出结果是一个“盒子模型”(width,height,padding,margin,border,top,left...)，精确表示了每个元素的大小和位置，并且所有的相对单位都转化成了绝对单位
    ![](https://web-dev.imgix.net/image/C47gYyWYVMMhDmtYSLOWazuyePF2/IIr281DuPwRi9fiXhNg4.png?auto=format&w=1232)

5. 将各个节点绘制到屏幕上
    > 最后，我们知道哪些节点是可见的，以及它们的计算样式和几何形状，现在需要将渲染树上的每个节点转化为屏幕上的实际像素。此步骤通常称为“绘画”或“光栅化”

## 从Event Loop谈JS的运行机制
这里会用到上文中的几个概念：
- JS引擎线程
- 事件触发线程
- Event Loop轮询处理线程
- 定时器触发线程

然后再理解一个概念：
- JS分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个`执行栈`
- 主线程之外，`事件触发线程`管理着一个`任务队列`，只要异步任务有了运行结果，就在`任务队列`之中放置一个事件
- 一旦`执行栈`中的所有同步任务执行完毕（此时JS引擎线程空闲）系统就会读取`任务队列`，将可运行的异步任务添加到`执行栈`中，开始执行。
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/21/1611938b898ed9ef~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### 事件循环机制进一步补充

我们需要明确一个概念，看下面一段代码：

`window.onload = function fn() {}` 其中 load 表示window对象的一个事件，而后面的 fn函数 则代表load事件对应的处理函数

事件是一直在的，不管你有没有添加处理函数，它都在那里，不会说你没有添加对应的事件处理函数，该事件就不存在了

而事件处理函数，是我们后来添加的，在对应事件被触发时会自动调用我们绑定的事件处理函数

JS引擎线程只干一件事，就是读取`执行栈`并执行JS代码，也就是说想要让JS代码执行，代码必须放入`执行栈`中

而异步代码是存放在`事件触发线程`上的`任务队列`中的。这是在两个不同的地方。

怎么让`事件触发线程`的`任务队列`中的JS代码放入 JS引擎线程的`执行栈`中呢？这就出现了`Event Loop轮询处理线程`，这个单独的线程就干这一件事情

`事件触发线程`是如何工作的呢？

一般情况`事件触发线程`处于睡眠状态 等待其他线程将它唤醒并将`事件处理函数`发送给它，然后由它将`事件处理函数`放入`任务队列`中。它只干这么一件事情。
如上fn函数，在load事件发生时，浏览器唤醒`事件触发线程`并把绑定的`事件处理函数`传过去，然后由`事件触发线程`将函数放入`任务队列`中。
后续由`Event Loop轮询处理线程`从`任务队列`中将函数取走，放入`JS引擎线程`的执行栈中。
> 从上可知，任务队列的添加只能由事件触发线程来做(生产者)，而任务队列的消费由轮询处理线程来操作(直接消费者)，然后转交给JS引擎线程执行(间接消费者)。

### 单独说说定时器
上述事件循环机制的核心是：JS引擎线程和事件触发线程

但事实上里面还有一些细节，如：调用`setTimeout`后，是如何等待特定时间后才添加到事件队列中的？

是JS引擎线程检测的吗？当然不是，它是由`定时器线程`控制的（可以理解为JS引擎线程自己都忙不过来，根本无暇分身）

为什么要单独的定时器线程？因为Javascript引擎是单线程的，如果出现阻塞状态就会影响计时的准确性，因此很有必要单独开一个线程用来计时。

一但时间到了，会唤醒`事件触发线程`并传递回调函数，然后由`事件触发线程`将函数放入`任务队列`中

> 我们可以看到，各个线程的职责是很单一的，一个线程就做一件事情，我们平常写代码中也要遵守这种单一原则

## 总结
- 可能本次分享的内容对于我们日常开发来说并没有多大作用，但至少我们在面试的时候可以拿来装杯。开玩笑的！！！
- 对于前端性能优化而言，我觉得是有一定指导意义的

参考：
- https://juejin.cn/post/6844903553795014663
- https://blog.51cto.com/u_11451275/4780160
- https://blog.csdn.net/sauphy/article/details/50507653
- https://web.dev/critical-rendering-path-render-tree-construction/
- https://zhuanlan.zhihu.com/p/366456720
