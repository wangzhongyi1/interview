# http强缓存和协商缓存

## 强缓存
### expires
- http1.0 的产物，指定资源过期的时间点
    + 在过期时间之前使用浏览器本地缓存
    + 到达过期时间就向服务器发送请求获取资源
    + 但是有一些问题
        * 首先这样设置，太不灵活了，在服务端资源更新时，客户端不能及时更新
        * 然后由于过期时间点是读取的客户端时间，但是客户端时间是用户可以随意更改的
### cache-control: max-age=10
- 然后由于 expires 存的的问题，就出现了 cache-control
- cache-control 设置 `max-age`，是一个相对的时间
    + 相对于服务器过了多久的一个时间段，所以就解决了客户端时间更改而导致的问题
    + 但是这样也不够灵活，也没有解决资源更改，客户端即时更新的问题

## 协商缓存
- 由于上述的强制缓存的问题，所以才出现了协商缓存
- 使用协商缓存，首先要把 `cache-control` 设置为 `no-cache`
### last-modified 和 if-modified-since
- `response header` 中返回 last-modified，标识文件最后一次修改时间
- 然后后续请求，会在 `request header` 的 `if-modified-since` 字段中带上 `last modified`的值
- 然后后端判断资源最新修改时间是否和传过来的时间相同
    + 如果相同，就返回 `304状态码`，告诉浏览器使用缓存
    + 否则返回200，并把最新资源返回
- 但是这种方式也会有问题
    + 如果你更改了文件名，然后又把文件名改回去，这样也被认为这个文件更改了，导致缓存失效
    + 由于 `last-modified` 能检查到的是秒级的，所以如果在 1s 内多次修改无法判断
    + 某些服务器不能精确得到文件的最后修改时间

### Etag 和 if-none-match
- 最终的解决方案是基于 Etag 的协商缓存策略
- Etag 是更加服务器文件内容生产的唯一标识
    + 在 `response header` 中会返回 `Etag`
    + 然后在后续请求中，会在 `request header` 中的 `if-none-match` 字段带上 Etag的值
        * 由后端判断文件内容是否发生变化
        * 但是也有缺点，就是每次请求后端都要执行 `Etag` 生成算法，消耗服务器性能
